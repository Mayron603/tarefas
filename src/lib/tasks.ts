import clientPromise from "./database";
import { Collection, ObjectId } from "mongodb";
import type { Task, TaskStatus } from "./types";

// Helper function to get the tasks collection
async function getTasksCollection(): Promise<Collection<Omit<Task, 'id'>>> {
  const client = await clientPromise;
  const db = client.db();
  return db.collection<Omit<Task, 'id'>>("tasks");
}

// Get all tasks
export async function getTasks(): Promise<Task[]> {
  const collection = await getTasksCollection();
  const tasks = await collection.find({}).sort({ deadline: 1 }).toArray();
  // Map MongoDB _id to string id and ensure the object is serializable
  return tasks.map((task) => {
    const { _id, ...rest } = task;
    return {
      ...rest,
      id: _id.toString(),
      _id: _id, // Keep original _id for server-side logic if needed, but it should be serializable now
    };
  }) as unknown as Task[];
}

// Add a new task
export async function addTask(task: Omit<Task, "_id" | "id" | "status" | "resolution" | "proofImage">): Promise<void> {
  const collection = await getTasksCollection();
  // When adding, we don't need to convert _id as it's generated by MongoDB
  await collection.insertOne({ ...task, status: 'todo' });
}

// Update a task's status
export async function updateTaskStatus(taskId: string, status: TaskStatus): Promise<void> {
    const collection = await getTasksCollection();
    await collection.updateOne(
        { _id: new ObjectId(taskId) },
        { $set: { status: status } }
    );
}

// Mark a task as done with a resolution and optional proof image
export async function completeTask(taskId: string, resolution: string, proofImage?: string): Promise<void> {
    const collection = await getTasksCollection();
    await collection.updateOne(
        { _id: new ObjectId(taskId) },
        { $set: { status: 'done', resolution: resolution, proofImage: proofImage } }
    );
}

// Delete a task
export async function deleteTask(taskId: string): Promise<void> {
    const collection = await getTasksCollection();
    await collection.deleteOne({ _id: new ObjectId(taskId) });
}
