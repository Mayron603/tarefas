import clientPromise from "./database";
import { Collection, ObjectId } from "mongodb";
import type { Task } from "./types";

// Helper function to get the tasks collection
async function getTasksCollection(): Promise<Collection<Omit<Task, 'id'>>> {
  const client = await clientPromise;
  const db = client.db();
  return db.collection<Omit<Task, 'id'>>("tasks");
}

// Get all tasks
export async function getTasks(): Promise<Task[]> {
  const collection = await getTasksCollection();
  const tasks = await collection.find({}).sort({ deadline: 1 }).toArray();
  // Map MongoDB _id to string id and ensure the object is serializable
  return tasks.map((task) => ({
    ...task,
    id: task._id.toString(),
  }));
}

// Add a new task
export async function addTask(task: Omit<Task, "_id" | "id" | "status" | "resolution">): Promise<void> {
  const collection = await getTasksCollection();
  // When adding, we don't need to convert _id as it's generated by MongoDB
  await collection.insertOne({ ...task, _id: new ObjectId(), status: 'inprogress' });
}

// Update a task's status
export async function updateTaskStatus(taskId: string, status: Task['status']): Promise<void> {
    const collection = await getTasksCollection();
    await collection.updateOne(
        { _id: new ObjectId(taskId) },
        { $set: { status: status } }
    );
}

// Mark a task as done with a resolution
export async function completeTask(taskId: string, resolution: string): Promise<void> {
    const collection = await getTasksCollection();
    await collection.updateOne(
        { _id: new ObjectId(taskId) },
        { $set: { status: 'done', resolution: resolution } }
    );
}
